# 운영체제

## 1. 운영체제와 컴퓨터

### 1-1. 운영체제와 컴퓨터

#### 운영체제의 역할

- CPU 스케줄링과 프로세스 관리
  
- 메모리 관리
  
- 디스크 파일 관리
  
- I/O 디바이스 관리
  

#### 운영체제의 구조

![스크린샷 2024-03-11 오전 9 28 10](https://github.com/woorifisa-service-dev-2nd/test-repo/assets/67616146/79c00b59-6f34-478c-82d8-b7a639c6dc21)
#### 시스템콜

- 운영체제가 커널에 접근하기 위한 인터페이스
  
- 유저 프로그램이 운영체제의 서비스를 받기 위헤 커널 함수를 호출할 때 사용
  

ex) 시스템콜의 수행 과정

1. 유저 프로그램이 fs.readFile()이라는 I/O 요청으로 트랩 발동
  
2. 유저 모드에서 파일을 읽지 않고 커널 모드로 들어가 파일을 읽고 다시 유저 모드로 돌아가기
  
3. 그 뒤에 있는 유저 프로그램의 로직을 수행
  

해당 과정을 통해 컴퓨터 자원에 대한 직접 접근을 차단할 수 있고 프로그램을 다른 프로그램으로부터 보호할 수 있다.

### 1-2. 컴퓨터의 요소

#### CPU

- 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치
  
- 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행하는 일꾼
  

처리과정

- 관리자 역할을 하는 운영체제의 커널이 프로그램을 메모리에 올려 프로세스로 만들면 CPU가 이를 처리
  

제어장치

- 프로세스 조작을 지시하는 CPU의 한 부품
  

레지스터

- CPU 안에 있는 매우 빠른 임시기억장치
  
- CPU와 직접 연결되어 있으므로 연산 속도가 메모리보다 수십 배에서 수백 배까지 빠름
  
- CPU는 자체적으로 데이터를 저장할 수 없기 때문에 레지스터를 거쳐 데이터를 전달
  

CPU의 연산 처리

1. 제어장치가 메모리에 계산될 값을 로드하고 레지스터에도 로드
  
2. 제어장치가 레지스터에 있는 값을 계산하라고 산술논리연산장치에 명령
  
3. 제어장치가 계산된 값을 다시 '레지스터에서 메모리로' 계산할 값을 저장
  

인터럽트

- 어떤 신호가 들어와을 때 CPU를 잠깐 정지시키는 것
  

#### DMA 컨트롤러

- I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치
  

#### 메모리

- 전자회로에서 데이터의 상태, 명령어 등을 기록하는 장치로, 보통 RAM을 일컫어 메모리라고 한다.
  
- CPU는 계산을, 메모리는 기억을 담당한다.
  

#### 타이머

- 몇 초 안에는 작업이 끝나야 한다는 것을 정하고 특정 프로그램에 시간 제한을 다는 역할
  

#### 디바이스 컨트롤러

- 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU
  

- 옆에 붙어 있는 로컬 버퍼는 각 디바이스에서 데이터를 임시로 저장하기 위한 작은 메모리
  

## 2. 메모리

### 2-1. 메모리 계층

<img width="356" alt="스크린샷 2024-03-11 오후 10 20 23" src="https://github.com/woorifisa-service-dev-2nd/test-repo/assets/67616146/c0538785-0ced-4f76-9628-84d0f6fcb9b3">
#### RAM

- 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요 시마다 CPU에 빠르게 전달
  

#### 캐시

- 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
  

#### 캐시히트

- 캐시에서 원하는 데이터를 찾는 것
  

#### 캐시미스

- 해당 데이터가 캐시에 없다면 주메모리로 가서 데이터를 찾아오는 것
  

#### 웹 브라우저의 캐시

쿠키

- 만료기한이 있는 키-값 저장소
  

로컬 스토리지

- 만료기한이 없는 키-값 저장소
  
- 도메인 단위로 저장, 생성
  
- 웹 브라우저를 닫아도 유지
  

세션 스토리지

- 만료기한이 없는 키-값 저장소
  
- 탭 단위로 생성
  
- 탭을 닫을 때 해당 데이터 삭제
  

### 2-2. 메모리 관리

#### 가상 메모리

- 메모리 관리 기법의 하나로 컴퓨터가 실제 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것
  
- 가상 주소는 메모리관리장치에 의해 실제 주소로 변환되며, 이 때문에 사용자는 실제 주소를 의식할 필요 없이 프로그램을 구축 가능
  

페이지 폴트

- 가상 메모리(프로스세의 주소 공간)에는 존재하지만 실제 메모리인 RAM에는 없는 데이터에 접근했을 경우 발생
  

스와핑

- 페이지 폴트가 발생할 경우, 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것
  

#### 스레싱

- 메모리의 페이지 폴트율이 높은 것을 의미하며, 이는 컴퓨터의 심각한 성능 저하를 초래할 수 있음
  
- 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생
  

스레싱이 일어나는 과정

1. 페이지 폴트가 일어나면 CPU 이용률이 낮아짐
  
2. 운영체제는 CPU가 한가하다고 생각하여 가용성을 높이기 위해 더 많은 프로세스를 메모리에 올림
  
3. 이 행위가 반복되면서 스레싱 발생
  

#### 메모리 할당

메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당하는데, 연속 할당과 불연속 할당으로 나뉜다.

연속 할당

- 메모리에 연속적으로 공간을 할당하는 것
  

불연속 할당

- 메모리를 연속적으로 할당하지 않는 불연속 할당은 현대 운영체제가 쓰는 방법으로 페이징 기법이 있음
  

페이징

- 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
  

세그멘테이션

- 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식
  

페이지드 세그멘테이션

- 프로그램을 의미 단위인 세그먼트로 나눠 공유나 보안 측면에 강점을 두고 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 것
  

## 3. 프로세스와 스레드

### 3-1. 프로세스와 컴파일 과정

프로세스 - 컴퓨터에서 실행되고 있는 프로그램

스레드 - 프로세스 내 작업의 흐름

프로그램은 컴파일러가 컴파일 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 번역하여 실행할 수 있는 파일을 만드는 것이다.

컴파일러 - 오류처리, 코드 최적화 작업을 하며 어셈블리어로 변환

### 3-2. 프로세스의 상태

생성 상태 - 프로세스가 생성된 상태로 fork() 또는 exec() 함수를 통해 생성

대기 상태 - 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기하고 있으면 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태

대기 중단 상태 - 메모리 부족으로 일시 중단된 상태

실행 상태 - CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태

중단 상태 - 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태

일시 중단 상태 - 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태

종료 상태 - 메모리와 CPU 소유권을 모두 놓고 가는 상태

### 3-3. 프로세스의 메모리 구조

#### 스택

- 지역 변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역
  
- 함수가 호출될 때마다 호출될 때의 환경 등 특정 정보가 스택에 계속해서 저장
  

#### 힙

- 동적으로 할당되는 변수들을 담음
  
- malloc(), free() 함수를 통해 관리할 수 있으며 동적으로 관리되는 자료 구조의 경우 사용
  

### 3-4. PCB

- 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터(프로세스 제어 블록)
  
- 프로세스가 생성되면 운영체제는 해당 PCB를 생성
  

#### 컨텍스트 스위칭

- PCB를 교환하는 과정
  
- 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생
  
- 컴퓨터는 많은 프로그램을 동시에 실행하는 것처럼 보이지만 어떠한 시점에서 실행되고 있는 프로세스는 단 한개이며, 많은 프로세스가 동시에 구동되는 것처럼 보이는 것은 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 실행되기 때문
  

### 3-5. 멀티프로세싱

- 여러 개의 프로세스 즉, 멀티프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것
  
- 이를 통해 하나 이상의 일을 병렬로 처리할 수 있으며 특정 프로세스의 메모리, 프로세스 중 일부에 문제가 발생하더라도 다른 프로세스를 이용해서 처리할 수 있으므로 신뢰성이 높음
  

#### IPC

- 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘
  
- 클라이언트가 데이터를 요청하고 서버가 클라이언트의 요청에 응답하는 것도 예시
  
- ex) 공유 메모리, 파일, 소켓
  

### 3-6. 스레드와 멀티스레딩

#### 스레드

- 프로세스의 실행 가능한 가장 작은 단위
  

#### 멀티 스레딩

- 프로세스 내 작업을 여러 개의 스레드로 처리하는 기법
  
- 스레드끼리 자원을 공유하므로 효율성이 높음
  
- 장점
  
  - 한 스레드가 중단되어도 다른 스레드가 실행 상태일 수 있어서 중단되지 않은 빠른 처리 가능
    
- 단점
  
  - 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어져 있는 프로세스에 영향을 줄 수 있음
    

### 3-7. 공유 자원과 임계 영역

#### 공유 자원

- 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수
  
- 이 공유 자원을 2개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태라고 함
  

#### 임계 영역

- 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
  
- 해결하기 위한 방법은 뮤텍스, 세마포어, 모니터
  
- 이들은 모두 lock 메너키즘을 사용하는데 화장실에 A가 들어가면 문을 잠그고 다음 사람이 기다리다 A가 나오면 들어가는 방법
  

#### 뮤텍스

- 프로세스나 스레드가 공유 자원을 lock()을 통해 잠금 설정하고 사용한 후에는 unlock()을 통해 잠금해제하는 객체
  

#### 세마포어

- 일반화된 뮤텍스
  
- 간단한 정수 값과 두 가지 함수 wait 및 signal로 공유 자원에 대한 접근 처리
  
- wait()는 자신의 차례가 올 때까지 기다리는 함수이며, signal()은 다음 프로세스로 순서를 넘겨주는 함수
  

### 3-8. 교착 상태

- 2개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태
  

#### 해결방법

1. 교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 '은행원 알고리즘'' 사용
  
2. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지우기
  
3. 교착 상태는 드물게 발생해서 이를 처리하는 비용이 더 크므로 그냥 작업 종료
  

## 4. CPU 스케줄링 알고리즘

#### 4-1. 비선점형 방식

프로세스가 스스로 CPU 소유권을 포기하는 방식이며, 강제로 프로세스를 종료하지 않는다. 따라서 컨텍스트 스위칭으로 인한 부하가 적다.

#### FCFS

- 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘
  

#### SJF

- 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘
  

#### 우선순위

- 오래된 작업일수록 우선순위를 높이는 SJF의 단점을 보완한 알고리즘
  

### 4-2. 선점형 방식

#### 라운드 로빈

- 각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘
  

#### SRF

- 중간에 실행 시간이 더 짧은 작업이 들어와도 기존 짧은 작업을 모두 수행하고 그 다음 짧은 작업을 이어나가는데, SRF는 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘
  

#### 다단계 큐

- 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라운드 로빈이나 FCFS 등 다른 스케줄링 알고리즘을 적용한 것
