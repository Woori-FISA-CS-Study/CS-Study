# 📂 해시 테이블

해시 테이블 : 해시함수를 사용해서 변환한 값을 index로 삼아 key와 value를 저장하는 자료구조

해시맵 : 해시 테이블의 구현체
ex) 파이썬의 dictionary, 루비의 Hash, 자바의 Map
<br>
<br>

## 🔗 해시 함수

해시 함수 : 데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수다. <br>
예를 들어, 어떠한 정수를 10으로 나눈 나머지를 return하는 함수가 있다고 하자.
이 또한 간단한 해시 함수다.
무조건 0~9 사이의 값이 리턴되기 때문이다.

<br>

매핑 전 원래 데이터의 값 : 키(key) <br>
매핑 후 데이터의 값 : 해시값(hash value)<br>
매핑하는 과정 자체 : 해싱(hashing)

<br>

![image](https://github.com/Woori-FISA-Algorithm-Study/doYouKnowAlgorithm/assets/65431814/01655048-5d3f-4cb3-a6b6-bbc071259ae2)

해시 함수를 이용해서 key를 hash value로 매핑하고, 이 hash value를 index로 삼아 데이터의 value를 데이터가 저장되는 곳인 buckets(혹은 slots)에 저장한다.

<br>

cf. 해시는 보안 분야에서도 널리 사용된다고 한다. 키와 해시값 사이에 직접적인 연관이 없기 때문에 해시값만 가지고는 키를 온전히 복원하기 어렵기 때문이다.

<br>
<br>

## 🎯 해시 테이블의 특징

- 해시테이블의 기본 연산 : 삽입, 삭제, 탐색(search)
  해시 테이블은 key-value가 1:1 매핑되어 있기 때문에 검색, 삽입, 삭제 과정에서 모두 평균적으로 O(1)의 시간복잡도를 갖는다.

- 키 기반의 빠른 액세스 : 키를 사용하여 값을 빠르게 검색하거나 수정할 수 있다. 커다란 데이터를 해시해서 짧은 길이로 축약할 수 있기 때문에 데이터를 비교할 때 효율적이다.

- 순서를 보장하지 않음 : 해시맵은 내부적으로 키의 순서를 보장하지 않는다.

- 키의 중복 불가 : 같은 키를 중복해서 사용할 수 없다. 이미 존재하는 키에 대해 값을 저장하면 기존 값이 덮어씌워진다.

- null 키와 값 : 해시맵은 null 키와 null 값을 저장할 수 있다. 하지만 키는 중복이 불가하므로 null 키는 하나만 저장될 수 있다.

- 키 기반의 유연성 : 어떤 객체든 키로 사용할 수 있다.

<br>
<br>

## 🤛 해시 충돌

해시 함수는 입력값의 길이가 어떻든 고정된 길이의 값을 출력하고, 해쉬값의 개수보다 대개 많은 키값을 해쉬값으로 변환(many-to-one 대응)하기 때문에 (비둘기집의 원리) 입력값이 다르더라도 같은 결과값이 나오는 경우가 있다.
즉, 서로 다른 두 개의 키에 대해 동일한 해시값을 내는 해시충돌(collision)이 발생한다.


![image](https://github.com/Woori-FISA-Algorithm-Study/doYouKnowAlgorithm/assets/65431814/7a809aa5-47d7-41b9-9f05-46a84de4b882)

위 예시에서 해시함수는 ‘John Smith’와 ‘Sandra Dee’를 모두 ‘02’로 매핑해 해시충돌을 일으키고 있다.

<br>
<br>

## 🤔 해시 충돌 해결방법

### 1. 분리 연결법 (seperate chaining)

각 버킷은 연결리스트나 트리로 구현.
한 버킷(슬롯) 당 들어갈 수 있는 엔트리의 수에 제한을 두지 않아 충돌이 발생하면, 해당 버킷의 연결리스트에 새로운 키-값 쌍을 추가하여 모든 자료를 해시테이블에 담는 방식.
즉, 해당 버킷에 데이터가 이미 있다면 체인처럼 노드를 추가하여 다음 노드를 가리키는 방식으로 구현(연결리스트)한다.
구현이 쉽고 유연하다는 장점을 가지나 메모리 문제를 야기할 수 있다.
![image](https://github.com/Woori-FISA-Algorithm-Study/doYouKnowAlgorithm/assets/65431814/af68653d-63cc-42e7-91aa-0677413e904b)
위 예시 그림의 해시함수는 ‘John Smith’와 ‘Sandra Dee’를 같은 해시값(152)으로 매핑하고 있다.
이 경우 해당 해시값에 대응하는 동일한 버킷에 두 개 데이터를 저장해 둔다.

<br>

### 2. 개방 주소법 (open address)

chaining과 달리 한 버킷당 들어갈 수 있는 엔트리가 하나뿐인 방식.
대신 충돌이 발생하면, 다른 버킷의 위치를 찾아 삽입을 시도한다.
이때 다른 위치를 찾는 과정은 또 여러 방법으로 나뉜다.

- 선형 조사 (Linear Probing) : 최초 해시값에 해당하는 버킷에 다른 데이터가 저장돼 있으면 해당 해시값에서 고정 폭(예컨대 1칸)을 옮겨 다음 해시값에 해당하는 버킷에 액세스하여 빈 위치를 찾는다.
  ![image](https://github.com/Woori-FISA-Algorithm-Study/doYouKnowAlgorithm/assets/65431814/5b51b0f0-4171-47c3-84a3-035caf10b8e6)

  위 그림처럼 52~56까지 데이터가 저장돼 있고 임의의 키의 최초 해시값이 52라면 탐사를 네 번 수행하고 나서 원하는 위치를 찾을 수 있다.

  <br>
  
  이 경우에는 특정 해시 값의 주변이 모두 채워져 있는 일차 군집화(primary clustering) 문제에 취약하다.
  예를 들어 모든 키가 100이라는 해시값으로 매핑이 될 경우 충돌은 100%가 된다.
  따라서 해시 충돌이 해시 값 전체에 균등하게 발생할 때 유용한 방법이다.

<br>

- 제곱 조사 (Quadratic Probing) : 고정 폭으로 이동하는 선형 탐사와 달리 그 폭이 제곱수로 늘어난다.
  ![image](https://github.com/Woori-FISA-Algorithm-Study/doYouKnowAlgorithm/assets/65431814/1d61774e-2b4c-48f0-8e93-9531ddb9f67e)

  임의의 키값에 해당하는 데이터에 액세스할 때 충돌이 일어나면 1의 제곱만큼, 칸을 옮긴다. 여기서도 충돌이 일어나면 이번엔 2의 제곱만큼, 그 다음엔 3의 제곱만큼 칸 옮기는 식이다.

  <br>

  제곱 탐사법을 이용한 경우 데이터의 밀집도가 선형 탐사법보다 낮기 때문에 다른 해시값까지 영향을 받아서 연쇄적으로 충돌이 발생할 가능성이 적다.
  하지만 선형 탐사법보다는 캐시의 성능이 떨어져서 속도의 문제가 발생한다.

<br>

- 이중 해싱 (Double Hashing) : 탐사할 해시값의 규칙값을 없애서 클러스터링을 방지한다.
  즉, 해시 함수를 이중으로 사용하는데, 하나는 최초의 해시값을 얻을 때, 다른 하나는 해시 충돌이 일어났을 때 탐사 이동폭을 얻기 위해 사용한다.
  이렇게 되면 최초 해시값이 같더라도 탐사 이동폭이 달라지고, 탐사 이동폭이 같더라도 최초 해시값이 달라져 위의 두 방법을 모두 완화할 수 있다.

<br>

### 3. 재해싱 (Rehashing)

해시 테이블이 가득 차거나 충돌이 너무 많이 발생할 경우, 해시 테이블의 크기를 늘리고 모든 키-값 쌍을 새로운 크기에 맞게 재삽입하는 방법이다.
이 방법은 메모리 사용량을 늘리는 대신 충돌을 줄이고 성능을 향상시키는 데 효과적이다.

<br>

### 4. 버킷 확장 (Bucket Expansion)

충돌이 일어나면 해당 버킷의 크기를 확장하여 여러 키-값 쌍을 저장할 수 있게 한다.

<br>

### 5. 올바른 해시 함수 사용

특정 값에 치우치지 않고 해시값을 고르게 만들어내는 좋은 해시 함수를 사용하는 것이다.
