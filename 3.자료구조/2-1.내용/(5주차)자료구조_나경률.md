# 자료구조

## 1. 복잡도

### 1-1. 시간 복잡도

문제를 해결하는데 걸리는 시간과 입력의 함수 관계

#### 빅오 표기법

```java
for(int i=0; i<10; i++) {
    for(int j=0; j<n; j++) {
        for(int k=0; k<n; k++) {
            if(true) ans++;
        }
    }
}
```

빅오 표기법은 입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것인데, 다음과 같은 코드에서 시간 복잡도를 빅오 표기법으로 나타내면 O(n^2)이다. 가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항을 없앤 것이다.

#### 시간 복잡도의 존재 이유

효율적인 코드로 개선하는데 척도로 사용된다. 어떤 로직이 O(n^2)만큼의 시간 복잡도를 가지고 16초가 걸린다면, O(n)의 시간 복잡도를 가지는 알고리즘으로 개선했을 때 4초로 줄일 수 있다는 것처럼 얼마만큼의 시간이 줄어들지 확연히 알 수 있다.

### 1-2. 공간 복잡도

프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양

## 2. 선형 자료 구조

### 2-1. 연결 리스트

데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조이다.

삽입과 삭제가 O(1)이 걸리며 탐색에는 O(n)이 걸린다.

- 싱글 연결 리스트 - next 포인터만 가짐
  
- 이중 연결 리스트 - next 포인터와 prev 포인터를 가짐
  
- 원형 이중 연결 리스트 - 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리킴
  

#### 2-2. 배열

같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합이다. 중복을 허용하고 순서가 있다. 탐색은 O(1)이고 삽입과 삭제에는 O(n)이 걸린다.

데이터 추가와 삭제를 많이 하는 것은 연결 리스트, 탐색을 많이 하는 것은 배열이 좋다.

#### 배열 vs 연결 리스트

탐색은 배열이 빠르고 연결 리스트는 느리다. 왜냐하면 배열은 인덱스로 임의 접근이 가능하지만 연결 리스트는 처음부터 쭉 살펴가야 한다.

데이터 추가 및 삭제는 연결리스트가 더 빠르고 배열이 느리다. 배열은 어떤 인덱스에 추가 및 삭제를 하면 그 이후 인덱스부터 모두 뒤로 밀려나거나 앞으로 떙겨와야하는 반면 연결 리스트는 원하는 위치를 지정해서 추가하면 자동으로 수행된다.

### 2-3. 스택

가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질(LIFO)을 가진 자료 구조

삽입 및 삭제에 O(1), 탐색에 O(n)이 걸린다.

### 2-4. 큐

먼저 들어간 데이터가 먼저 나오는 성질(FIFO)을 가진 자료 구조

삽입 및 삭제에 O(1), 탐색에 O(n)이 걸린다.

## 3. 비선형 자료 구조

일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조로 트리나 그래프가 있다.

#### 3-1. 그래프

정점과 간선으로 이루어진 자료 구조

어떠한 곳에서 어떠한 곳으로 무언가를 통해 간다고 했을 때,

- 정점 - 어떠한 곳
  
- 간선 - 무언가
  

##### 가중치

간선과 정점 사이에 드는 비용

#### 3-2. 트리

그래프 중 하나로, 그래프의 특징처럼 정점과 간선으로 이루어져 있고, 트리 구조로 배열된 일종의 계층적 데이터의 집합이다. 루트 노드, 내부 노드, 리프 노드 등으로 구성된다.

- 루트 노드 - 가장 위에 있는 노드
  
- 내부 노드 - 루트 노드와 내부 노드 사이에 있는 노드
  
- 리프 노드 - 자식 노드가 없는 노드
  
- 깊이 - 루트 노드로부터 특정 노드까지의 최단 거리
  
- 높이 - 루프 노트부터 리프 노드까지의 최장 거리
  
- 레벨 - 깊이
  
- 서브트리 - 트리 내의 하위 집합으로 트리 내에 있는 부분집합
  

##### 이진 트리

자식 노드 수가 2개 이하인 트리

##### 이진 탐색 트리

노드의 오른쪽 하위 트리에는 '노드 값보다 큰 값'이 있는 노드만 포함되고, 왼쪽 하위 트리에는 '노드 값보다 작은 값'이 들어 있는 트리

##### AVL 트리

왼쪽 오른쪽 서브 트리의 높이 차가 최대 1인 트리

#### 3-3. 힙

완전 이진 트리 기반의 자료 구조이며, 최소힙과 최대힙 두 가지가 있고 해당 힙에 따라 특정한 특징을 지킨 트리

- 최대힙 - 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야 함
  
- 최소힙 - 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 작아야 함
  

##### 최대힙의 삽입

힙에 새로운 요소가 들어오면, 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다. 이 새로운 노드를 부모 노드들과의 크기를 비교하며 교환해서 힙의 성질을 만족시킨다.

##### 최대힙의 삭제

최대힙에서 최대값은 루트 노드이므로 루트 노드가 삭제되고, 그 이후 마지막 노드와 루트 노드를 스왑하여 또다시 스왑 등의 과정을 거쳐 재구성된다.

#### 3-4. 우선순위 큐

우선순위 대기열이라고도 하며, 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조

#### 3-5. 맵

특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조

#### 3-6. 셋

특정 순서에 따라 고유한 요소를 저장하는 컨테이너이며, 중복되는 요소는 없고 오로지 희소한 값만 저장하는 자료 구조

#### 3-7. 해시 테이블

무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블
