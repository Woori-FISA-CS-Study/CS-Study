## 1. 복잡도

### 1-1. 시간 복잡도

**시간 복잡도란 ?**

- 입력 크기에 대해 어떠한 알고리즘이 실행되는데 걸리는 시간
- 주요 로직의 반복 횟수를 중점으로 측정

빅오 표기법

- 입력범위 n을 기준으로 해서 로직이 몇 번이나 반복되는지 나타내는 것.
- ‘입력크기 n’의 모든 입력에 대한 알고리즘 필요 시간이 10n^2 +n 일때 빅오표기법은 O(n^2)
- ‘가장 영향을 많이 끼치는’ 항의 상수 인자를 빼고 나머지 항 제거.

시간 복잡도의 존재 이유?

- 효율적인 코드로 개선하기 위해. O(n^2) → O(n), O(1) 을 지향

### 1-2. 공간 복잡도

**공간 복잡도란?**

- 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
- 정적 변수 선언 뿐 아니라 동적 재귀 함수로 인해 공간을 계속해서 필요로 할 경우도 포함.
- ex) inta[1004] → 1004 * 4바이트 의 크기가 필요.

### 1-3. 자료 구조에서의 시간 복잡도

- 평균, 최악의 시간 복잡도를 고려하여 사용.

   ![평균시간복잡도](https://github.com/Woori-FISA-CS-Study/CS-Study/assets/35751392/2e1e3afd-83f6-4d26-b510-0eac97bcf857)
  
![최악의 시간복잡도](https://github.com/Woori-FISA-CS-Study/CS-Study/assets/35751392/81d126ca-e6ef-4f12-9243-ce523007542c)

   
## 2. 선형 자료 구조

선형 자료 구조란 ? 요소가 일렬로 나열되어 있는 자료구조.

### 2-1. 연결 리스트

데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화.

### 2-1-1. 단순 연결 리스트**(Singly linked list)**

각 노드에 자료 공간과 한 개의 포인터 공간이 있고, 각 노드의 포인터는 다음 노드를 가리킴.

![2](https://github.com/Woori-FISA-CS-Study/CS-Study/assets/35751392/0b0dc456-3ec1-4873-9404-ecfcb7710e76)


### 2-1-2. 이중 연결**(Doubly linked list)**

next로 현재 노드에서 다음 노드로 갈 수 있지만 이전 노드로는 갈 수 없습니다. 이러한 단점을 해결하기 위해 노드에 앞 노드의 메모리 주소를 보관하는 포인터 prev를 만들어준 형태를 이중 연결 리스트(Doubly Linked List)라고 함.

![3](https://github.com/Woori-FISA-CS-Study/CS-Study/assets/35751392/8c36c567-856e-405f-89a4-00abd77f9c25)


### 2-1-3. 원형 연결 리스트(**Circular linked list)**

단순 연결 리스트(Singly Linked List)의 마지막 노드의 포인터가 NULL이 아닌 헤드를 가리키는 형태의 리스트 입니다. 따라서 리스트의 끝이 존재하지 않음.

![5](https://github.com/Woori-FISA-CS-Study/CS-Study/assets/35751392/a2cd8a4d-28ff-42f0-8a03-f227a72ad7e1)


### 2-1-4. 연결 리스트에서의 시간 복잡도

### 접근(Access) 시간 복잡도: O(n)

- 인덱스 x에 있는 노드에 접근하려면 Head에서 다음 노드로 x번 가면 된다.
- 마지막 노드에 접근하려면 Head에서 다음 노드로 n-1번 가야함.
- 최악의 경우 시간 복잡도 : O(n)

### 탐색(Find) 시간 복잡도: O(n)

- 배열을 탐색할 때와 같은 방법으로 구한다.
- 가장 앞 노드부터 다음 노드를 하나씩 보면서 원하는 데이터를 갖는 데이터를 찾는다. → 선형 탐색
- 링크드 리스트안에 찾는 데이터가 없거나 또는 찾으려는 데이터가 마지막 노드에 있는 경우 n개의 노드를 다 봐야함.
- 최악의 경우 시간 복잡도 : O(n)

### 삽입/삭제(Insertion/Deletion) 시간 복잡도: O(1)

- 삽입, 삭제할 노드의 주변 노드들의 Link만 수정하면 된다.
- 따라서 삽입, 삭제가 실행되는 시간은 특정 값에 비례하지 않고 항상 일정.
- 시간 복잡도 : O(1)

### 2-2. 배열

배열이란? 

- 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아 놓은 집합.
- 중복 허용, 순서 존재.

### [연결 리스트 VS 배열]

차이점 1. 시간 복잡도

차이점 2. 메모리 사용

- 배열은 사용하기 전 배열의 크기를 미리 선언, 크기의 수정이 불가능→ 메모리 사용이 비효율적 **(정적 할당)**
- 연결 리스트는 필요할 때마다 노드를 생성하여 연결→ 메모리를 효율적으로 사용 **(동적 할당)**
- 배열은 메모리 공간에 연속적으로 저장되어 있는 자료구조. → 인덱스를 통한 접근이 용이하고, 데이터 외에 다른 정보를 저장할 필요가 없음.
- 연결 리스트는 데이터를 저장할 공간 뿐만 아니라, 다음 노드의 주소를 저장하는 공간이 추가적으로 필요.

### 2-3. 벡터

벡터 : 동적으로 요소를 할당할 수 있는 동적배열

- 컴파일 시점에 개수를 모를때.
- 중복 허용, 순서 있음, 랜덤 접근 가능
- 탐색/맨뒤 요소 삭제&삽입 : O(1)
- push_back() : O(1) , 2^2 +1마다 크기를 2배로 늘림.
- pop_back(), erase(), find(), clear()
- 맨뒤/맨앞이 아닌 요소 삭제&삽입 : O(n)

### 2-4. 스택

스택 : 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질.(LIFO)

- 재귀함수, 알고리즘, 웹 브라우저 방문 기록
- 삽입&삭제 : O(1)
- 탐색 : O(n)

### 2-5. 큐

큐 : 먼저 집어넣은 데이터가 먼저 나오는 성질(FIFO)

- 삽입&삭제 : O(1)
- 탐색 : O(n)
- CPU 작업의 프로세스, 스레드 행렬, 네트워크 접속 기다리는 행렬, 너비우선 탐색, 캐시 등에 사용.
- push(), pop()

## 3. 비선형 자료 구조

일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조.

### 3-1. 그래프

그래프란? 정점과 간선으로 이루어진 자료구조.

- 지점 : 정점(V or U)
- 무엇을 통해 가는 것 : 간선
- 정점과 간선으로 이루어진 집합 : 그래프
- 가중치 : 간선과 정점 사이에 드는 비용.

### 3-2. 트리

트리란 ? 

- 그래프 중 하나로 그래프의 특징처럼 정점과 간선으로 이루어져 있음.
- 계층형 데이터의 집합.
- 루트 노트, 내부 노드, 리프 노드 등으로 구성.
- 트리로 이루어진 집합 : 숲
- 특징 : 1. 부모, 자식 계층 구조
    1. V -1 = E , 간선 수는 노드 수 -1
    2. 임의의 두 노드 사이의 경로는 ‘유일무이’ 하게 ‘존재’.
- 트리의 구성 :
    
    1 . 루트 노드 : 가장 위에 있는 노드
    2. 내부 노드 : 루트 노드와 내부 노드 사이에 있는 노드
    3. 리프 노드 :  자식 노드가 없는 노드
- 트리의 높이와 레벨
- 깊이 : 루트 노드로 부터 특정 노드까지의 최단 거리
- 높이 : 루트 노드부터 리프 노드까지 가장 긴 거리
- 레벨 : 보통 깊이와 같은 의미.
- 서브트리 : 트리 내의 하위 집합, 부분집합.

### 3-2-1. 이진 트리

이진 트리는 자식의 노드 수가 두 개 이하인 트리 의미.

- 정이진 트리 : 자식 노드가 0 또는 두 개인 이진 트리를 의미.
- 완전 이진 트리 : 왼쪽에서부터 채워진 이진 트리.
- 변질 이진 트리 :  자식 노드가 하나 밖에 없는 이진 트리.
- 포화 이진 트리 : 모든 노드가 꽉 차 있는 이진 트리.
- 균형 이진 트리 : 왼쪽-오른쪽 노드의 높이 차가 1 이하인 이진트리.

### 3-2-2. 이진 탐색 트리(BST)

- 노드의 오른쪽 하위 트리에는 ‘노드 값보다 큰 값’이 있는 노드만 포함.
- 왼쪽 하위 트리 ‘노드 값보다 작은 값’
- 삽입 순서에 따라 선형적일 수 있음. → 최악의 경우 O(n) 까지 걸릴 수 있음.

### 3-2-3. AVL 트리

- 선형적 트리가 되는 것을 방지/ 스스로 균형을 잡는 탐색 트리.
- 두 자식 서브 트리의 높이는 항상 최대 1만큼 차이.
- 탐색, 삽입, 삭제 : O(log n)

### 3-2-4. 레드 블랙 트리

- 균형 이진 탐색 트리
- 탐색, 삽입, 삭제 : O(log n)
- 추가 비트 저장 → 삽입, 삭제 중에 트리가 균형을 유지하도록 하는데 사용.
    
   ![rb](https://github.com/Woori-FISA-CS-Study/CS-Study/assets/35751392/d2ee6b49-940a-46b1-8d95-9de9ddfe5b90)

    
- **NIL node (leaf) :** 그림에서 사각형으로 된 리프 노드는 여기서 NIL node라고 함. 이 노드는 따로 key나 data를 포함하지 않으며 실제 코드에서도 구현하지 않는 "완전 가상의 노드"

### 3-3. 힙

힙이란?

**완전 이진 트리** 기반의 자료 구조.

- 최대힙 : 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 큼.
    
    각 노드의 자식 노트와의 관계도 재귀적으로 이루어져야 함.
    
- 최소힙 : 최소힙에서 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최솟값. 이러한 특징이 재귀적으로 이루어져야 함.

최대힙의 삽입

- 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입.
- 새로운 노드를 부모 노드들과의 크기를 비교, 교환하여 힙의 성질을 만족.

최대힙의 삭제

- 최대힙에서 최댓값은 루트 노트.
- 루트 노드가 삭제되고, 마지막 노드와 루트 노드를 스왑하여 또 다시 스왑 등의 과정을 거쳐 재구성.

### 3-4. 우선순위 큐

- 우선 순위 대기열.
- 대기열에서 우선 순위가 높은 요소가 낮은 요소보다 먼저 제공되는 자료구조.

### 3-5. 맵

- 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조.
- **레드 블랙 트리** 자료구조 기반으로 형성.
- 삽입하면 자동 정렬.
- map<string, int> 형태로 구현.
- 해시 테이블을 구현할 때 쓰임.

### 3-6. 셋

- 특정 순서에 따라 고유한 요소를 저장하는 컨테이너.
- 중복되는 요소 없음.
- 오로지 유니크한 값만 저장.

### 3-7. 해시 테이블

- 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블.
- 삽입, 삭제, 탐색 : 평균적으로 O(1)의 시간 복잡도.

### 예상질문

1. list , map 차이와 언제 써야 할까?
- list :  순차적으로 데이터를 저장하거나 엑세스 할때 사용.
- Map: '키-값' 의 쌍으로 나열되어 있어 키값을 통해 원하는 값을 한번에 찾아낼 수 있다.
-> 값을 순차적으로 사용하고 할 때는 List 사용, 키값을 가지고 원하는 값을 빠르게 찾고 싶을 때는 Map 사용
2. 사용자 아이디를 통해 사용자 프로필을 검색하는 경우에 list vs map 중 어느것이 더 효율적일까?
