# 자료구조

자료구조 : 데이터를 효율적으로 관리하고 수정, 삭제, 탐색,저장할 수 있는 데이터 집합

<br>
<br>

## section 5.1 복잡도

### 5.1.1 시간 복잡도

시간 복잡도의 존재 이유는 비효율적인 코드 개선을 위한 척도가 되기 때문이다.
O(n^2)보다는 O(n), O(n)보다는 O(1)을 지향해야 한다.

### 5.1.2 공간 복잡도

공간 복잡도는 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양을 말한다.
정적 변수로 선언된 것 말고도 동적으로 재귀함수로 인해 공간을 계속해서 필요로 할 경우도 포함된다.

### 5.1.3 자료 구조에서의 시간 복잡도

보통 시간복잡도를 생각할 때 평균과 최악의 시간 복잡도를 고려하면서 쓴다.

<br>
<br>

## section 5.2 선형 자료 구조

### 5.2.1 연결 리스트

연결리스트는 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화 시킨 자료 구조이다.
삽입, 삭제가 O(1)이 걸리고 탐색에는 O(n)이 걸린다.

- 싱글 연결 리스트 : next 포인터만 가진다.
- 이중 연결 리스트 : next 포인터와 prev 포인터를 가진다.
- 원형 이중 연결 리스트 : 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리키는 것을 말한다.

### 5.2.2 배열

배열은 같은 타입의 변수들로 이루어져 있고 크기가 정해져 있으며 인접한 메모리 위치에 있는 데이터를 모아놓은 집합이다.
중복을 허용하고 순서가 있다.
데이터 추가와 삭제를 많이 하는 것은 연결 리스트, 접근(참조)를 많이 하는 것은 배열로 하는 것이 좋다.

#### 랜덤 접근과 순차적 접근

직접 접근이라 하는 랜덤 접근은 동일 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능이다.
데이터가 저장된 순대로 검색해야 하는 순차적 접근과는 반대이다.

#### 배열과 연결 리스트

배열은 상자를 순서대로 나열한 데이터 구조이며 몇 번째 상자인지만 알면 요소를 꺼낼 수 있다.
연결 리스트는 상자를 선으로 연결한 형태의 구조이며 요소를 알려면 상자 내부를 하나씩 확인해야 한다.
따라서 참조가 많이 일어나는 작업은 배열이 빠르고 연결 리스트는 느리다.

### 5.2.3 벡터

벡터는 동적으로 요소를 할당할 수 있는 동적 배열이다.
중복을 허용하고 순서가 있고 랜덤 접근이 가능하다.

### 5.2.4 스택

스택은 가장 마지막으로 들어간 데이터가 가장 첫번째로 나오는 성질을 가진 자료구조이다 (LIFO)
재귀적인 함수, 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 쓰인다.
삽입과 삭제는 O(1), 탐색은 O(n)이 걸린다.

### 5.2.5 큐

큐는 먼저 집어넣은 데이터가 먼저 나오는 성질을 지닌 자료 구조이다(FIFO)
나중에 넣은 데이터가 먼저 나오는 스택과는 반대 개념이다.
삽입과 삭제는 O(1), 탐색은 O(n)이 걸린다.
CPU작업을 기다리는 프로세스, 스레드 또는 네트워크 접속을 기다리는 행렬 등에 사용된다.

<br>
<br>

## section 5.3 비선형 자료 구조

### 5.3.1 그래프

그래프는 정점과 간선으로 이루어진 자료구조이다.

#### 정점과 간선

어떤 곳에서 무언가를 통해 간다고 할 때, 어떤 곳은 정점, 무언가는 간선이 된다.
정점으로 나가는 간선을 해당 정점의 outdegree라고 하며 들어오는 간선을 해당 정점의 indegree라고 한다.
정점과 간선으로 이루어진 집합이 그래프이다.

- 가중치 : 간선과 정점 사이에 드는 비용

### 5.3.2 트리

트리는 그래프 중 하나로 정점과 간선으로 이루어져 있고 트리 구조로 배열된 일종의 데이터 집합이다.
내부 노드, 루트노드, 리프노드 등으로 구성된다.
트리로 이루어진 집합을 숲이라고 한다.

- 루트노드 : 가장 위에 있는 노드
- 내부노드 : 루트노드와 내부노드 사이에 있는 노드
- 리프노드 : 자식노드가 없는 노드

- 깊이 : 루트 노드로부터 특정 노드까지의 최단 거리
- 높이 : 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리
- 레벨 : 깊이와 같은 의미
- 서브트리 : 트리 내의 하위 집합, 즉 트리 내에 있는 부분 집합

#### 이진 트리

이진트리는 자식의 노드 수가 두 개 이하인 트리다.

- 정이진 트리 : 자식 노드가 0 또는 두 개인 이진트리
- 완전 이진 트리 : 왼쪽부터 채워진 이진 트리
- 변질 이진 트리 : 자식 노드가 하나밖에 없는 이진 트리
- 포화 이진 트리 : 모든 노드가 꽉 차 있는 이진 트리
- 균형 이진 트리 : 왼쪽, 오른쪽 노드 높이 차이가 1 이하인 이진 트리

#### 이진 탐색 트리

이진탐색트리는 오른쪽 하위 트리에는 노드 값보다 큰 값이 있는 노드만 포함되고, 왼쪽 하위 트리에는 노드 값보다 작은 값이 들어있는 트리다.

#### AVL 트리

AVL(Adelson-Velsky and Landis tree)는 최악의 경우 선형적 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리이다.
두 자식 서브트리의 높이는 항상 최대 1만큼 차이난다.

#### 레드 블랙 트리

균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)이다.
모든 리프 노드와 루트 노드는 블랙이고 어떤 노드가 레드면 그 노드의 자식은 반드시 블랙이다 등의 규칙을 기반으로 균형을 잡는 트리이다.

### 5.3.3 힙

힙은 완전 이진 트리의 자료 구조이며 최소힙과 최대힙 두 가지가 있고 해당 힙에 따라 특정한 특징을 지킨 트리를 말한다.

- 최대힙 : 루트 노드에 있는 키는 모든 자식 중 가장 커야 한다.
- 최소힙 : 로트 노드에 있는 키는 모든 자식 중 가장 최소값이어야 한다.

#### 최대힙의 삽입

힙에 새로운 요소가 들어오면 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.
새로운 노드를 부모 노드와 비교하며 교환해서 힙의 성질을 만족한다.

#### 최대힙의 삭제

최대힙에서 최대값은 루트노드이므로 루트노드가 삭제되고 그 이후 마지막 노드와 루트노드를 스왑하는 과정을 거쳐 재구성된다.

### 5.3.4 우선순위 큐

우선순위 큐는 우선순위 대기열이라고도 하며 대기열에서 우선 순위가 높은 요소가 우선순위 낮은 요소보다 먼저 제공되는 자료 구조이다.
힙을 기반으로 구현된다.

### 5.3.5 맵

맵은 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조이다.
맵을 쓸 때는 map<string, int> 구조로 구현한다.
map은 해시 테이블을 구현할 때 쓰며 정렬을 보장하지 않는 unordered_map과 정렬을 보장하는 map 두 가지가 있다.
map을 순회할 때는 키에 해당하는 값을 first, 키에 매핑된 값에 해당하는 값을 second로 탐색 가능하다.

### 5.3.6 셋

셋은 특정 순서에 따라 고유한 요소를 저장하는 컨테이너이며 중복되는 요소는 없고 희소한 값만 저장하는 자료구조이다.
pair는 두 가지 형을 담을 수 있는 구조이며 first, second로 그 인자에 접근한다.

### 5.3.7 해시 테이블

해시 테이블은 무한에 가까운 데이터를 유한한 개수의 해시 값으로 매핑한 테이블이다.
삽입, 삭제, 탐색 시에 평균 O(1)의 시간복잡도를 가지며 unordered_map으로 구현한다.
