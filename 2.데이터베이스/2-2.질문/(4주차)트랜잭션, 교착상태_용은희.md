# 트랜잭션
## 트랜잭션이란?
트랜잭션(Transaction 이하 트랜잭션)이란, 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위
## 트랜잭션의 특징
원자성 (Atomicity)
일관성 (Consistency)
독립성 (Isolation)
지속성 (Durability)

### 원자성
원자성은 트랜잭션이 DB에 모두 반영되거나, 전혀 반영되지 않거나를 뜻한다.
All or Nothing을 생각하면 된다.

### 일관성
일관성은 트랜잭션 작업 처리의 결과가 항상 일관되어야 한다를 뜻한다.
즉, 데이터 타입이 반환 후와 전이 항상 동일해야 한다.

### 독립성
독립성은 하나의 트랜잭션은 다른 트랜잭션에 끼어들 수 없고 마찬가지로 독립적임을 의미한다.
즉, 각각의 트랜잭션은 독립적이라 서로 간섭이 불가능하다.

### 지속성
지속성은 트랜잭션이 성공적으로 완료되면 영구적으로 결과에 반영되어야 함을 뜻한다.
보통 commit 이 된다면 지속성은 만족할 수 있다.

## 트랜잭션의 Commit 과 Rollback
### Commit
하나의 트랜잭션이 성공적으로 끝나서 데이터베이스가 일관성있는 상태에 있음을 의미한다.

### Rollback
트랜잭션의 원자성이 깨질 때, 즉 하나의 트랜잭션 처리가 비정상적으로 종료 되었을 때의 상태를 뜻한다.
Rollback 이 이뤄진다면 트랜잭션을 다시 실행하거나 부분적으로 변경된 결과를 취소할 수 있다.

## 트랜잭션의 상태

![image](https://github.com/Woori-FISA-CS-Study/CS-Study/assets/35751392/fd3a5fd9-9750-4269-8023-a204b93d5c74)

트랜잭션은 논리적으로 5가지의 상태에 있을 수 있다.
- Active
    - 트랜잭션이 현재 실행 중인 상태
- Failed
    - 트랜잭이 실행되다 오류가 발생해서 중단된 상태
- Aborted
    - 브랜잭션이 비정상 종료되어 Rollback 이 수행된 상태
- Partially Committed
    - 트랜잭션의 연산이 마지막까지 실행되고 Commit이 되기 직전 상태
- Committed
    - 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태
 
## 교착상태(Deadlock)란? 
데이터베이스에서는 기본적으로 트랜잭션들의 동시성을 제어하기 위해 잠금(Locking)을 사용한다.   
이러한 잠금은 데이터의 무결성을 지켜주지만 그 부작용으로 교착상태가 발생할 수 있다.   
교착상태란 여러개의 트랜잭션들이 실행을 하지 못하고 서로 무한정 기다리는 상태를 의미한다.  

## 교착 상태 해결방법 

### 예방 기법 

각 트랜잭션이 실행되기전에 필요한 데이터를 모두 잠금(Locking)하는 것. 하지만 데이터가 많이 필요할 경우 모든 데이터를 잠금해야 되기 때문에 트랜잭션의 병행성을 보장하지 못한다. 뿐만 아니라 몇몇 트랜잭션들은 계속해서 처리를 못하게 되는 기아 상태가 발생할 수 있다.

### 회피 기법 

위의 단점 때문에 실제로 교착상태를 해결하기 위한 방법으로 회피 기법이 많이 사용된다. 회피 기법은 자원을 할당할 때 시간 스탬프(Time Stamp)를 사용하여 교착상태가 일어나지 않도록 회피하는 방법으로 Wait-Die 방식과 Wound-Wait 방식이 있다.

### Wait-Die 방식 
다른 트랜잭션이 데이터를 점유하고 있을 때 기다리거나(Wait) 포기(Die)하는 방식으로 선행 트랜잭션이 접근하면 대기(wait), 후행 트랜잭션이 접근하면 포기(die)한다. 즉, 오래된 프로세스에게 대기의 기회를 제공하고, 최신 프로세스는 자주 복귀함으로써 오버헤드의 가능성이 있다.


### Wound-Wait 방식 

다른 트랜잭션이 데이터를 점유하고 있을 때 빼앗거나(Wound) 기다리는(Wait) 방식으로 선행 트랜잭션이 접근하면 선점(wound), 후행 트랜잭션이 접근하면 대기(wait)한다. 즉, 오래된 프로세스에게 선점의 기회를 제공하고 최신 프로세스는 대기함에 따라 복귀를 최소화한다.


### 낙관적 병행 기법 

낙관적 병행 기법은 트랜잭션이 실행되는 동안에는 아무런 검사를 하지 않고, 트랜잭션이 다 실행된 이후에 검사 후 문제가 있다면 되돌리는 방법

### 빈도 낮추기 

교착 상태의 빈도를 낮추는 방법으로는

- 트랜잭션을 자주 커밋
- 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득( SELECT ~ FOR UPDATE)의 사용을 피한다.
- 테이블 단위의 잠금을 획득해 갱신을 직렬화

## **데이터베이스 정규화(Normalization) 란?**

관계형 데이터베이스의 설계에서 **중복을 최소화하게 데이터를 구조화하는 프로세스**를 정규화라고 한다.

정규화의 기본 목표는 **관련이 없는 함수 종속성은 별개의 릴레이션으로** 표현하는 것이다.

정규화된 결과를 **정규형**이라고 하며, 정규형은 기본 정규형 고급 정규형으로 나뉜다.

- 기본 정규형 : 제1정규형, 제2정규형, 제3정규형, BCNF(보이스/코드 정규형)
- 고급 정규형 : 제4정규형, 제5정규형

정규화의 장점으로는 **이상 현상의 발생 가능성을 줄이지만**,

단점으로는 **연산 시간이 증가**한다.


![image (1)](https://github.com/Woori-FISA-CS-Study/CS-Study/assets/35751392/2820921a-89ba-433d-9b49-b50f25997a8c)

### **제 1 정규형**

릴레이션에 속한 모든 속성의 도메인이 **더 이상 분해되지 않는 원자값으로만 구성**된 정규형이다.

### **제2정규형**

릴레이션이 제1정규형에 속하고, **기본키가 아닌 모든 속성이 기본키에 완전 함수 종속**되면 제2정규형에 속한다.

제1정규형에 속하는 릴레이션이 제2정규형을 만족하게 하려면, **부분 함수 종속을 제거**하고 모든 속성이 기본키에 **완전 함수 종속**되도록 릴레이션을 분해하는 정규화 과정을 거쳐야 한다.

- 완전 함수 종속
    - 어떤 속성이 기본키에 대해 완전히 종속일 때
- 부분 함수 종속
    - 어떤 속성이 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 속성 중 일부만 종속될 때

### **제3정규형**

릴레이션이 제2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 **이행적 함수 종속이 되지 않으면** 제3정규형에 속한다.

- 이행적 함수 종속
    - A → B , B → C 인 경우 A → C 가 성립될 때
    - 즉, A를 알면 B를 알고 그를 통해 C를 알 수 있는 경우를 의미
 
### **BCNF**

릴레이션의 함수 종속 관계에서 **모든 결정자가 후보키**이면 BCNF에 속한다.  
하나의 릴레이션에 여러개의 후보키가 존재할 수도 있는데, 이런 경우는 제3정규형까지 모두 만족하더라도 이상 현상이 발생할 수 있다.   
이러한 이상현상을 해결하기 위해 제3정규형보다 좀 더 엄격한 제약조건을 제시한 것이 BCNF이다. 

### BCNF 정규화

- 학생번호-교수 릴레이션은 함수 종속 관계가 성립하지 않는 동등한 학생번호, 교수 속성으로 구성하고 {학생번호, 교수}가 기본키의 역할을 담당한다. 즉, 후보키가 아닌 결정자가 존재하지 않기때문에 BCNF에 속한다.
- 교수-특강 릴레이션은 교수와 특강이 함수 종속 관계를 띄우며, 교수가 유일한 후보키이자 기본키이다. 즉, 후보키가 아닌 결정자가 존재하지 않기때문에 BCNF에 속한다.

### **고급 정규형 (제4정규형, 제5정규형)**

- 제4정규형
    - 릴레이션이 BCNF를 만족하면서, 함수 종속이 아닌 **다치 종속**(MVD: Multi Valued Dependency) 를 제거해야 만족할 수 있다.
- 제5정규형
    - 릴레이션이 제4정규형을 만족하면서 후보키를 통하지 않는 **조인 종속**(JD: Join Dependency) 을 제거해야 만족할 수 있다.

실제로 데이터베이스를 설계할 때 모든 릴레이션이 무조건 제5정규형에 속하도록 분해해야 하는 것은 아니다.

오히려 그렇게 되면 비효율적인 경우가 많다.

일반적으로 **제3정규형**이나 **BCNF**에 속하도록 릴레이션을 분해하여 **데이터 중복을 줄이고 이상 현상이 발생하는 문제를 해결**한다고 한다.

### **역정규화**

Join이 너무 많아지는 DB 설계와 쿼리는 요청을 처리하는 시간을 증가시키는 문제가 있기 때문에 모든 주요 Entity를 분리하는 것이 좋은 것이 아니라 DB의 전반적인 성능을 향상시킬 수 있는 구조화 과정을 거치는 것이 필요하다.

역정규화는  중복을 허용하며 Entity를 다시 통합하거나 분할하여 정규화 과정을 통해 도출된 DB 구조를 재조정하는 과정.

