# 데이터베이스 2주차

# 인덱스

인덱스를 사용하면 조회 성능을 높일 수 있다.

그러나 무분별하게 사용하면 삭제, 삽입, 수정 성능이 저하될 수 생길 수 있다.

## 🔖 인덱스의 종류

- **클러스터형 인덱스**
    - 영어 사전에 비유 (클러스터형 인덱스 열 기준으로 정렬됨)
    - 테이블당 한개만 설정할 수 있음
    - `PRIMARY KEY` 설정시 자동으로 클러스터형 인덱스가 생성됨
    - `UNIQUE NOT NULL`로 설정시 클러스터형 인덱스가 생성됨
        - 우선도 : PRIMARY KEY > UNIQUE NOT NULL
- **보조 인덱스 (비클러스터형 인덱스)**
    - 색인 (찾아보기)에 비유
    - `UNIQUE KEY` 설정시 자동으로 보조 인덱스 생성됨

스토리지 엔진종류에 따라 인덱스의 내부 동작이 다르다.

- `InnoDB` : B 트리
- `MyISAM` : B 트리
- `MEMORY(HEAP)` : Hash, B 트리
- `NDB` : Hash, B 트리

## 🍔 인덱스의 내부 동작 (B-TREE)

### B-Tree (Balanced Tree)

B-tree는 각 노드가 2개 이상의 자식 노드를 가질 수 있는 트리 구조로, 리프 노드의 깊이는 최소 높이와 최대 높이 사이에서 조절되며, 이를 위해 노드의 병합과 분할이 발생할 수 있다.

인덱스에서 B-Tree의 노드는 **`페이지`**로 이루어져 있다. 페이지는 **16KByte**의 최소 저장 단위이다. 따라서 아무리 작은 데이터 하나를 저장하더라도 한 페이지 만큼의 저장 공간을 차지하게 된다.

### 페이지 분할

리프 페이지에 더 이상 빈공간이 없을 때, 비어 있는 페이지를 한 개 확보한 후에 리프 페이지의 데이터를 공평하게 나누는 작업.

cost high

### 클러스터형 인덱스와 보조 인덱스의 내부 구조 차이

- **클러스터형 인덱스**
    - 루트 페이지/중간 페이지 :
        - key : 인덱스가 설정된 열
        - value : 다음 페이지 번호
    - 리프 페이지 :
        - key : 인덱스가 설정된 열
        - value : `찾고자 하는 행 데이터 그 자체`

<aside>
💡 리프페이지 == 데이터페이지

</aside>

클러스터형 인덱스는 데이터 검색 속도가 보조 인덱스보다 빠르다

→ 리프페이지가 바로 데이터 페이지이기 때문에!!!

다음과 같은 Student 테이블이 있다고 가정하자.

| Column | Type |
| --- | --- |
| 학번 (PK) | INT |
| 이름 | VARCHAR(10) |
| 학과 | VARCHAR(10) |

⬇️ 클러스터형 인덱스를 구성한 이후의 모습

<img width="977" alt="스크린샷 2024-01-31 오후 12 44 37" src="https://github.com/castello/spring_basic/assets/73164845/2a909b14-b08d-41d1-8858-1ab488be3d7e">

⬇️ 클러스터형 인덱스에 행을 추가했을 때 모습

<img width="956" alt="스크린샷 2024-01-31 오후 12 46 07" src="https://github.com/castello/spring_basic/assets/73164845/5065347e-13cc-48ee-9e2d-4062983ca898">

- **보조 인덱스**
    - 루트 페이지/중간 페이지 :
        - key : 인덱스가 설정된 열
        - value : 다음 페이지 번호
    - 리프 페이지 :
        - key : 인덱스가 설정된 열
        - value : 데이터 페이지의 **주소값과 offset**

<aside>
💡 리프페이지 =/= 데이터 페이지

</aside>

보조 인덱스는 데이터 페이지를 건드리지 않고, 별도의 장소에 인덱스 페이지를 생성한다.

⬇️ 보조 인덱스를 구성한 이후의 모습

<img width="903" alt="스크린샷 2024-01-31 오후 12 47 03" src="https://github.com/castello/spring_basic/assets/73164845/c537fada-3cfe-44a8-949b-ba55b44b422c">

⬇️ 보조 인덱스에 행을 추가했을 때 모습

<img width="879" alt="스크린샷 2024-01-31 오후 12 47 41" src="https://github.com/castello/spring_basic/assets/73164845/0e7110f0-375a-42b5-995b-5cbd1c8e39ff">

리프페이지가 바로 데이터 페이지인지의 여부에 따라 INSERT와 SELECT의 속도 차이가 난다.

리프페이지가 바로 데이터 페이지이면 (클러스터형 인덱스) SELECT는 더 빠르고 INSERT는 더 느릴 것이다. 그렇지만 리프페이지가 데이터페이지가 아니라면, (보조 인덱스라면) SELECT는 더 느리지만 INSERT는 좀 더 빠를 것이다.

- **클러스터 인덱스와 보조 인덱스가 혼합된 경우**

<aside>
💡 보조 인덱스의 리프페이지의 값이 **주소값+offset**이 아닌 **클러스터형 인덱스의 키값**을 가지게 된다.

</aside>

<img width="952" alt="스크린샷 2024-01-31 오후 12 48 26" src="https://github.com/castello/spring_basic/assets/73164845/70deb701-2cb3-48a3-87b5-0d7de24dbfc8">

`SELECT * FROM Student WHERE name = 용은희`

> 보조인덱스 루트 페이지를 탐색 → `용은희` 는 이진천보다 뒤에 있으므로 `2번 페이지`를 탐색
용은희의 클러스터형 인덱스의 값(학번)인 201710456을 가지고 데이터 페이지를 탐색
용은희의 학번은 201710000보다 크고 201810000보다 작으므로 1001번 페이지를 탐색
찾았다!
>
- 클러스터형 인덱스와 보조 인덱스를 분리하지 않고 이렇게 구성하는 이유
    - 보조 인덱스의 리프 페이지가 `데이터 페이지의 주소값과 offset`으로 구성된 경우 먼저 데이터의 삽입으로 인해 클러스터형 인덱스의 리프 페이지가 재구성되어 **페이지의 번호와 offest이 대폭 변경될 수 있다.**

      단 한건의 행 삽입으로 페이지 번호 및 오프셋이 대폭 변경되므로, **보조 인덱스 역시 많은 부분이 재구성되어야하만 한다.** → 엄청난 시스템 부하

    - 그러나 보조인덱스의 리프페이지가 `클러스터형 인덱스의 키값`을 가리키는 경우에는 하나의 행이 추가된다고 해도 **클러스터형 인덱스에서만 페이지 분할 작업이 일어날 뿐 보조인덱스에는 큰 변화가 생기지 않는다.**

  ### 인덱스의 성능 비교

    - 테이블의 약 **15%**이상을 스캔하는 경우에는 mySQL이 인덱스를 사용하지 않고 **table full scan**을 실시한다.
    - 인덱스가 생성된 열에 함수나 연산을 하게 되면 인덱스 사용이 안될 수 있다.

      `SELECT * FROM emp WHERE emp_no * 1 = 10000;`

    - 카디널리티가 높은 열에 인덱스를 걸어야 효과적이다.  = 중복도가 낮은 열

      예를들어 gender와 같이 `female`, `male` 두가지 값만 존재하는 열에 인덱스를 건다면 효과가 떨어진다. 인덱스의 관리 비용과 INSERT등에서 효율이 떨어진다는 점을 고려하면 인덱스를 쓰지 않는게 나을 수 있다.

    - 자주 사용되어야 가치가 있다. SELECT가 많이 일어나야 효과적이다. INSERT가 많이 일어나는데 인덱스를 걸면 성능이 나빠질 수 있다.
    - JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다.
    - 외래키를 지정한 열에는 자동으로 외래 키 인덱스가 생성된다.

# 면접 질문

1. 인덱스의 장단점에 대해서 말해보세요
2. 어떤 열에 인덱스를 거는 것이 효율적일까요?
3. 클러스터형 인덱스와 비클러스터형 인덱스의 차이점은 무엇인가요?
4. 인덱스를 잘못 사용할 경우 어떤 문제가 발생할 수 있나요?
5. b-tree인덱스와 해시 인덱스의 차이점은?