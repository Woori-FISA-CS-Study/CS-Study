`데이터베이스` : 데이터를 일정한 규칙에 따라 분류해 놓은 모음

`DBMS(Database Management System)` : 데이터베이스를 관리하는 통합 시스템

데이터베이스를 사용함에따라 기존의 파일 시스템과는 다르게 실시간으로 데이터를 공유하고 접근할 수 있다.

## 🍡 데이터베이스의 종류

1. **RDBMS (Relational DBMS)**

   관계형 데이터베이스. 행과 열로 이루어져 있음

2. **NoSQL**

   Not Only SQL의 줄임말로 비관계형 데이터베이스.

   고정되어 있지 않은 테이블 스키마를 가진다.

   종류 : key-value(Redis), document(MongoDB), graph, wide-column


## 📝 엔티티 (=릴레이션, 테이블)

여러 속성(attribute)을 가진 명사, 객체

- 강한 엔티티 : 혼자 존재할 수 있는 엔티티
- 약한 엔티티 : 다른 엔티티에 의존적인 엔티티
  ![Untitled (9)](https://github.com/GyeongEun-Kim/Algorithm/assets/73164845/bc782167-5943-414c-b0c3-af445aa5d807)


## 💡 필드 타입

### 숫자 타입

- **TINYINT**
- **SMALLINT**
- **MEDIUMINT**
- **INT**
- **BIGINT**

+) 데이터베이스를 설계할 때 테이블의 ID를 INT로 할것인지 BIGINT로 할것인지 생각해보기

[[면접] id를 왜..bigint..?](https://velog.io/@nayoon-kim/면접-id를-왜..bigint)

### 날짜 타입

- **DATE** : `2024-01-22`
- **DATETIME** : `2024-01-22 19:23:43`

  1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 까지 지원

- **TIMESTAMP** : `2024-01-22 19:23:43`

  1970-01-01 00:00:01 ~ 2038-01-19 03:14:07 까지 지원


[Should I use the datetime or timestamp data type in MySQL?](https://stackoverflow.com/questions/409286/should-i-use-the-datetime-or-timestamp-data-type-in-mysql)

TIMESTAMP는 UNIX timestamp를 사용하기 때문에 2038년까지만 사용가능하다.

하지만 여러국가의 시간에 맞춰 저장해야 하는 상황이라면 TIMESTAMP를 쓰는 것이 나을 수 있다.

### 문자 타입

- **CHAR와 VARCHAR**

  `CHAR`는 지정한 길이만큼 메모리를 차지한다. 실제로 저장된 문자열의 길이가 그보다 작더라도 처음 설정한 길이만큼 자리를 차지한다.

  그러나 `VARCHAR`는 가변길이의 타입이므로 처음에 설정한 길이보다 작은 길이의 문자열이 저장된다면 메모리에도 더 적은 길이로 올라가게 된다.

- **TEXT**

  큰 문자열을 저장할 때 사용. 주로 게시판의 본문을 저장할 때 사용

- **BLOB**

  이미지나 동영상 등의 큰 파일을 저장할 때 사용. 그러나 주로 amazon s3에 올리고 url만 db에 저장하는 식으로 사용.

- **ENUM과 SET**

  `ENUM`은 목록 중 하나만 선택가능, `SET`은 목록 중 여러개 선택 가능

  `ENUM`과 `SET`을 사용하면 메모리를 줄일 수 있고 데이터의 정합성을 높일 수 있다. 그러나 애플리케이션의 수정이 필요한 경우 `ENUM`을 수정하는 것이 까다로울 수 있다.


# 👑 정규화

릴레이션간의 잘못된 종속관계 때문에 발생한 이상현상을 없애기 위해 테이블을 분해하는 과정

## 제 1 정규형

## 제 2 정규형

## 제 3 정규형

## BCNF

# 🌵 트랜잭션

트랜잭션이란 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 단위이다. SQL 쿼리의 모음이 트랜잭션 단위가 될 수 있고 트랜잭션 단위로 ROLLBACK, COMMIT할 수 있다.

## 🍀 ACID (트랜잭션의 특징)

### Atomicity 원자성

> all or nothing
>

하나의 트랜잭션에 속하는 쿼리들은 모두 수행되거나, 수행되지 않아야한다.

더 찾아볼 것 : 트랜잭션 전파

### Consistency 일관성

트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다는 뜻이다.

### Isolation 격리성

하나의 트랜잭션이 수행될 때 다른 트랜잭션이 끼어들 수 없는 성질

### 🚪 트랜잭션 격리 수준

![Untitled (5)](https://github.com/GyeongEun-Kim/Algorithm/assets/73164845/5c4bf4dc-34c3-4d3c-866f-f78a2d529c05)

![Untitled (6)](https://github.com/GyeongEun-Kim/Algorithm/assets/73164845/f60a5f2c-9d61-461d-8850-4ccc2b3bb67f)

- Phantom read
- Non-repeatable read
- Dirty read

### Durability 지속성

성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다는 특성

- 체크섬, 저널링, 롤백…

![Untitled (7)](https://github.com/GyeongEun-Kim/Algorithm/assets/73164845/144f693c-f96b-426c-b235-a072da22eafd)

mysql은 모듈식 아키텍쳐로 스토리지 엔진을 쉽게 갈아낄 수 있다는 장점이 잇다. (ISAM과 InnoDB의 차이?)

쿼리 캐시 지원

# 🔖 인덱스

— 이것이 mySQL이다를 읽고 정리한 내용입니다 —

인덱스를 사용하면 조회성능을 높일 수 있다. 그러나 무분별하게 사용하면 삭제, 삽입, 수정 성능에 문제가 생길 수 있다.

## 인덱스의 종류

- **클러스터형 인덱스**
    - 영어 사전에 비유 (클러스터형 인덱스 열 기준으로 정렬됨)
    - 테이블당 한개만 설정할 수 있음
    - `PRIMARY KEY` 설정시 자동으로 클러스터형 인덱스가 생성됨
    - `UNIQUE NOT NULL`로 설정시 클러스터형 인덱스가 생성됨
        - 우선도 : PRIMARY KEY > UNIQUE NOT NULL
- **보조 인덱스 (비클러스터형 인덱스)**
    - 색인 (찾아보기)에 비유
    - `UNIQUE KEY` 설정시 자동으로 보조 인덱스 생성됨

## 인덱스의 내부 동작

### B-Tree (Balanced Tree)

인덱스 B-Tree의 노드는 **페이지**로 이루어져있다. 페이지는 **16KByte**의 최소 저장 단위이다. 따라서 아무리 작은 데이터 하나를 저장하더라도 한 페이지 만큼의 저장 공간을 차지하게 된다.

### 페이지 분할

리프페이지에 더이상 빈공간이 없을때, 비어있는 페이지를 한개 확보한 후에 리프페이지의 데이터를 공평하게 나누는 작업. cost high

### 클러스터형 인덱스와 보조 인덱스의 내부 구조 차이

- **클러스터형 인덱스**
    - 루트 페이지/중간 페이지 :
        - key : 인덱스가 설정된 열
        - value : 다음 페이지 번호
    - 리프 페이지 :
        - key : 인덱스가 설정된 열
        - value : 찾고자 하는 행 데이터 그 자체

<aside>
💡 리프페이지 == 데이터페이지

</aside>

클러스터형 인덱스는 데이터 검색 속도가 보조 인덱스보다 빠르다

→ 리프페이지가 바로 데이터 페이지이기 때문에!!!

![IMG_6435 (1)](https://github.com/GyeongEun-Kim/Algorithm/assets/73164845/2cb8b812-d900-4f3c-837b-8cb1e3d60f11)

<클러스터형 인덱스에 행을 추가했을 경우>

![IMG_6437 (1)](https://github.com/GyeongEun-Kim/Algorithm/assets/73164845/3b09f16e-e96b-45ad-b549-0c1d5ed4017e)

- **보조 인덱스**
    - 루트 페이지/중간 페이지 :
        - key : 인덱스가 설정된 열
        - value : 다음 페이지 번호
    - 리프 페이지 :
        - key : 인덱스가 설정된 열
        - value : 데이터 페이지의 **주소값과 offset**

<aside>
💡 리프페이지 =/= 데이터 페이지

</aside>

![IMG_6436 (1)](https://github.com/GyeongEun-Kim/Algorithm/assets/73164845/305e326d-67cc-4879-9fd9-aa86745a4240)

![IMG_6438 (1)](https://github.com/GyeongEun-Kim/Algorithm/assets/73164845/a6378605-9aa3-4786-af6c-3bcff0cc5b14)

보조 인덱스는 데이터 페이지를 건드리지 않고, 별도의 장소에 인덱스 페이지를 생성한다.

리프페이지가 바로 데이터 페이지인지의 여부에 따라 INSERT와 SELECT의 속도 차이가 난다.

리프페이지가 바로 데이터 페이지이면 (클러스터형 인덱스) SELECT는 더 빠르고 INSERT는 더 느릴 것이다. 그렇지만 리프페이지가 데이터페이지가 아니라면, (보조 인덱스라면) SELECT는 더 느리지만 INSERT는 좀 더 빠를 것이다.

- **클러스터 인덱스와 보조 인덱스가 혼합된 경우**

<aside>
💡 보조 인덱스의 리프페이지의 값이 **주소값+offset**이 아닌 **클러스터형 인덱스의 키값**을 가지게 된다.

</aside>

![IMG_6434 (1)](https://github.com/GyeongEun-Kim/Algorithm/assets/73164845/ec754b69-13bb-449d-b06c-67e733623759)

`SELCET addr FROM mixedTBL WHERE name=”임재범”;`

> 1. (페이지 번호 10번-루트 페이지 읽음) “임재범”이 “은지원”보다 큰값이므로 200번 페이지에 있다는 것을 확인
2. (페이지 번호 200번 읽음) “임재범”의 클러스터형 인덱스의 키 값이 LJB임을 확인한 후, 클러스터 인덱스의 루트페이지로 가서 찾음.
3. (페이지 번호 20번 읽음) “LJB”는 “KBS”보다 크고 “SSK”보다 작으므로 1001번 페이지에 있는 것을 확인
4. (페이지 번호 1001번 읽음) “LJB”를 찾고 addr값인 “서울”을 찾아냄.


- 클러스터형 인덱스와 보조 인덱스를 분리하지 않고 이렇게 구성하는 이유
    - 보조 인덱스의 리프 페이지가 `데이터 페이지의 주소값과 offset`으로 구성된 경우 먼저 데이터의 삽입으로 인해 클러스터형 인덱스의 리프 페이지가 재구성되어 **페이지의 번호와 offest이 대폭 변경될 수 있다.**

      단 한건의 행 삽입으로 페이지 번호 및 오프셋이 대폭 변경되므로, **보조 인덱스 역시 많은 부분이 재구성되어야하만 한다.** → 엄청난 시스템 부하

    - 그러나 보조인덱스의 리프페이지가 `클러스터형 인덱스의 키값`을 가리키는 경우에는 하나의 행이 추가된다고 해도 **클러스터형 인덱스에서만 페이지 분할 작업이 일어날 뿐 보조인덱스에는 큰 변화가 생기지 않는다.**

  ### 인덱스의 성능 비교

    - 테이블의 약 **15%**이상을 스캔하는 경우에는 mySQL이 인덱스를 사용하지 않고 **table full scan**을 실시한다.
    - 인덱스가 생성된 열에 함수나 연산을 하게 되면 인덱스 사용이 안될 수 있다.

      `SELECT * FROM emp WHERE emp_no * 1 = 10000;`

    - 카디널리티가 높은 열에 인덱스를 걸어야 효과적이다.  = 중복도가 낮은 열

      예를들어 gender와 같이 `female`, `male` 두가지 값만 존재하는 열에 인덱스를 건다면 효과가 떨어진다. 인덱스의 관리 비용과 INSERT등에서 효율이 떨어진다는 점을 고려하면 인덱스를 쓰지 않는게 나을 수 있다.

    - 자주 사용되어야 가치가 있다. SELECT가 많이 일어나야 효과적이다. INSERT가 많이 일어나는데 인덱스를 걸면 성능이 나빠질 수 있다.
    - JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다.
    - 외래키를 지정한 열에는 자동으로 외래 키 인덱스가 생성된다.

인덱스를 모든 열에 거는 것이 좋을까요?

# 조인


![Untitled (8)](https://github.com/GyeongEun-Kim/Algorithm/assets/73164845/9d8b4324-fa47-49f1-9c36-b15c12438962)


## 조인의 원리

- 중첩 루프 조인 (NLJ)

  2중포문과 같은 원리로 접근. 대용량 테이블에는 사용하지 않는다.

- 정렬 병합 조인

  각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 후에 조인

- 해시 조인

  해시테이블을 기반으로 조인하는 방법. 동등 조인에서만 사용 가능