# 데이터베이스

## 데이터베이스 : 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음

## DBMS : 해당 데이터베이스를 제어, 관리하는 통합 시스템

ex) MySQL, Oracle

## 1. 데이터베이스의 기본

### 1-1. 엔터티 : 사람, 장소, 개념 등 여러 개의 속성을 지닌 명사

엔터티는 여러 속성을 가진다.

ex) 회원(엔터티) - 이름, 아이디, 주소, 전화번호(속성)

### 1-2. 릴레이션 : 데이터베이스에서 정보를 구분하여 저장하는 기본 단위

ex) 테이블

### 1-3. 속성 : 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

### 1-4. 도메인 : 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

ex) 성별 속성 - [남, 여] 라는 도메인

### 1-5. 필드와 레코드

- name, ID - 필드
  
- 쌓이는 행 단위의 데이터(집어넣은 값) - 레코드(튜플)
  

### 1-6. 관계

쇼핑몰에서 관계에 대해 알아보자.

유저는 하나의 유저 이메일을 갖는다. - 1:1 관계

유저는 여러 개의 상품을 장바구니에 담는다. - 1:N 관계

여러 유저가 여러 상품을 구매한다. - 1:M 관계

### 1-7. 키 : 테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치

기본키 - 유일성과 최소성을 만족시키는 키

- 유일성 - 하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질
  
- 최소성 - 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질
  

기본키의 종류

- 자연키 - 중복된 값들을 제외하며 중복되지 않는 것을 뽑다가 나온 키로 언젠가는 변하는 속성을 가짐
  
- 인조키 - 인위적으로 생성한 키로 변하지 않는 속성을 가짐(보통 기본키는 인조키)
  

외래키 - 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계 식별에 사용

후보키 - 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키

대체키 - 후보키가 2개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키

슈퍼키 - 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

## 2. ERD와 정규화 과정

## ERD - 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관계들을 정의한 것

### 2-1. 정규화 과정 - 데이터베이스 이상 현상을 해결하거나 릴레이션을 여러 개로 분리해서 저장 공간을 효율적으로 사용하는 것

- 제1정규형 - 릴레이션의 모든 도메인이 원자값(반복집합 X)
  
- 제2정규형 - 부분함수의 종속성 제거
  
- 제3정규형 - 기본키가 아닌 모든 속성이 이행적 함수종속 불만족
  
- 보이스/코드 정규형 - 모든 결정자가 후보키
  

## 3. 트랜잭션과 무결성

### 3-1. 트랜잭션 : 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위

트랜잭션의 특징(ACID)

- 원자성 - 트랜잭션과 관련된 일이 모두 수행되거나 되지 않았거나를 보장하는 것
  
- 일관성 - 허용된 방식으로만 데이터를 변경해야 하는 것
  
- 독립성 - 트랜잭션 수행 시 서로 끼어들지 못하는 것
  
- 지속성 - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
  

### 3-2. 무결성 : 데이터의 정확성, 일관성, 유효성을 유지하는 것

무결성 종류

- 개체 무결성 - 기본키로 선택된 필드는 빈 값을 허용 X
  
- 참조 무결성 - 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지
  
- 고유 무결성 - 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐
  
- NULL 무결성 - 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약조건
  

## 4. 인덱스 : 데이터를 빠르게 찾을 수 있는 하나의 장치

### 4-1. 트리

인덱스는 보통 B-트리라는 자료구조로 이루어진다. 이는 루트 노드, 리프 노트, 둘 사이의 브랜치 노드로 나뉜다.

인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문이다. 대수확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 말한다.

### 4-2. 인덱스 만드는 방법

- MySQL
  
  - 클러스터링 인덱스
    
    - 테이블 당 하나 설정 가능
      
    - 기본키로 만들거나 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스 생성 가능
      
  - 세컨더리 인덱스
    
    - create index ... 명령어 기반으로 세컨더리 인덱스 생성 가능
      
    - 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 성능이 좋음
      
- MongoDB
  
  - document를 만들면 자동으로 ObjectID가 형성되며 해당 키가 기본키로 설정
    
  - 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스 설정 가능
    

### 4-3. 인덱스 최적화 기법

1. 인덱스는 비용이다. 인덱스는 두 번 탐색하도록 강요한다. 또한, 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다. 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것이 답이 아니다. 또하느 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.
  
2. 항상 테스팅하라. 인덱스 최적화 기법은 서비스 특징에 따라 달라지는데 객체의 깊이, 테이블의 양 등이 다르기 때문이다. explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하여 걸리는 시간을 최소화해야 한다.
  
3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다. 보통 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.
  

## 5. 조인의 종류

## 조인 : 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

### 5-1. 내부 조인 : 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 표기

### 5-2. 왼쪽 조인 : 왼쪽 테이블의 모든 행이 결과 테이블에 표기

### 5-3. 오른쪽 조인 : 오른쪽 테이블의 모든 행이 결과 테이블에 표기

### 5-4. 합집합 조인 : 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

## 6. 조인의 원리

### 6-1. 중첩 루프 조인 : 중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법

### 6-2. 정렬 병합 조인 : 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 방법

### 6-3. 해시 조인 : 해시 테이블을 기반으로 조인하는 방법
