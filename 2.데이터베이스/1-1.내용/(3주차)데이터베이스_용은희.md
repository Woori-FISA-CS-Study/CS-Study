## DB란?

일정한 규칙,혹은 규약을 통해 구조화되어 저장되는 데이터의 모음집.

db를 제어,관리하는 통합 시스템 → dbms

### 1-1. 엔터티

명사. ex) 사람, 장소, 물건, 사건, 개념

약한 엔터티와 강한 엔터티

약한 엔터티는 강한 엔터티에 종속적.

### 1-2. 릴레이션

정보를 구분하여 저장하는 기본 단위.

릴레이션 관계형db → 테이블 (MySQL), NoSQL → 컬렉션(MongoDB)

### 1-3. 속성

릴레이션에서 관리하는 구체적 고유한 이름.

### 1-4. 도메인

릴레이션의 속성이 가진 값의 집합.

### 1-5. 필드와 레코드

- 행단위 : 레코드(튜플)

- 필드타입 : TINYINT, SMALLINT, MEDIUMINT,INT,BIGINT

- 날짜타입 : DATE,DATETIME,TIMESTAMP

- 문자 : CHAR(고정길이 문자열),VARCHAR(가변길이 문자열)

- 큰데이터 저장 : TEXT(큰 문자열), BLOB(이미지,동영상)

- 문자열 열거 : ENUM(단일 선택, 없는 값 입력시 빈문자열 삽입.) , SET (ENUM과 비슷하지만 여러개의 데이터를 선택할 수 있고 비트단위의 연산 가능.)

### 1-6. 관계

- 1:1 관계
- 1:N 관계
- N:M 관계

### 1-7. 키

테이블 간의 관계를 명확히. 테이블 자체 인덱스를 위해 설정된 장치. 

- 기본키 : pk , 유일성, 최소성
- 외래키 : fk,  다른 테이블의 기본키를 그대로 참조하는 값
- 후보키 : 기본키가 될 수 있는 후보. 유일성, 최소성
- 대체키 : 기본키 지정하고 남은 후보키들.
- 슈퍼키 : 유일하게 식별할 수 있는 유일성.

## 2. ERD와 정규화 과정

ERD : 데이터베이스 구축할때 가장 기초적인 뼈대 역할. 릴레이션 간의 관계들 정의.

### 2-1 .ERD 중요성 

시스템 요구사항 기반으로 작성. 

기반으로 데이터베이스 구축. 

관계형 구조에서는 유용하지만 비정형 데이터는 어려움.

### 2-2. 정규화 과정

릴레이션간의 잘못된 종속관계로 인해 데이터베이스 이상 현상, 저장공간 효율성을 위해

정규형원칙

자료의 중복성 감소, 독립적 관계

### 2-3. 제1정규형
- 모든 도메인이 더이상 분해 될 수 없는 원자값

### 2-4. 제 2정규형 
- 제 1정규형에 부합 && 부분함수 종속성 제거

### 2-5. 제3정규형 
- 이행함수 종속 제거

### 2-6. 보이스/코드 정규형 
- 결정자가 후보키가 아닌 함수 종속 관계 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

## 3. 트랜잭션과 무결성

### 3-1. 트랜잭션 
하나의 논리적 기능을 수행하기 위한 작업의 단위. 
- 트랜잭션 특징 : ACID
- 원자성 : all or nothing
- 커밋과 롤백 : 커밋은 여러 쿼리가 성공적으로 처리되었을때.
  커밋 수행되었다 → 하나의 트랜잭션이 성공적으로 수행되었다.
  각 쿼리는 하나의 트랜잭션 단위로 수행.
  데이터베이스에 영구적으로 저장됨.
  롤백 : 트랜잭션으로처리한 하나의 묶음 과정을 일어나기 전으로 되돌리는 일.
  커밋과 롤백 : 데이터 무결성 보장
- 트랜잭션 전파 :
 트랜잭션 수행 시 커넥션 단위로 수행하는데 커넥션 객체를 넘겨서 수행해야함.
 @Transactional :  애너테이션을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리.
- 일관성 : 허용된 방식, 규칙에 따라 유효함.
- 격리성 : 트랜잭션 수행 시 끼어들지 못하게 함.  여러 개의 격리 수준으로 나누어 격리성 보장.

### 무결성이란  
 데이터의 정확성, 일관성, 유효성을 유지하는 것.
- 개체 무결성 :  기본키로 선택된 필드는 빈값을 허용하지 않습니다.
- 참조 무결성 : 참조 관계에 있는 두 테이블은 일관된 값 유지.
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 속성 값은 모두 고유한 값.
- NULL 무결성 : 특정 속성 값에 null이 올 수 없다는 조건이 주어진 경우 속성값은 null이 될 수 없다는 제약조건.

## 4. 데이터베이스의 종류

### 4-1. 관계형 데이터 베이스
- MySQL
- PostgreSQL

### 4-2. NoSQL 
- SQL을 사용하지 않는 db
- MongoDB
- redis
### 4-3. 인덱스
- 인덱스의 필요성 : 데이터를 빠르게 찾을 수 있음.
- B-트리 : 인덱스의 자료구조 형태.
- 인덱스 만드는 법 (mysql 기준) 
- 클러스터형 인덱스 :  테이블당 하나 설정
- 세컨더리 인덱스 :  보조 인덱스, 여러개의 필드값을 기반으로 쿼리를 많이 보낼 때 생성.
- 하나만 쓴다면 클러스트형 인덱스가 성능이 더 좋음.
- 인덱스 최적화 기법
- 비용 고려 : 인덱스는 두 번 탐색이므로 읽기 비용이 듦. 컬렉션 양을 고려하여 고려.
- 테스팅 : explain() 함수 사용하여 걸리는 시간 확인 및 최소화.
- 복합 인덱스 : 같음(equal) > 정렬(order by) > 다중값(>,<) > 카디널리티(unique) 순

## 6.조인

### 6-1. 조인의 종류

![join](https://github.com/Woori-FISA-CS-Study/CS-Study/assets/35751392/538afd5d-d954-449a-95a9-bc58758b9ef1)


- inner join : 교집합. 두 테이블에서 모두 일치하는 부분

- left outer join : 왼쪽 테이블의 모든 행의 결과

- right outer join : 오른쪽 테이블의 모든 행의 결과

- full outer join : 합집합. 두개의 테이블 모든 데이터

### 6-2. 조인의 원리

- 중첩 루프 조인 : 중첩 for문 원리. 첫번째, 두번째 테이블 순으로 차례대로 행을 하나씩 읽음.

- 정렬 병합 조인 : 정렬 끝난 이후 조인 작업 수행. 대용량 테이블 조인. 범위 연산자(<,>) 있는 경우.

- 해시 조인 : 동등조인(=)에서만 사용. 빌드단계(메모리 내 해시테이블을 빌드하는 단계) → 프로브단계(레코드 읽음). 중첩루프조인보다 성능이 좋음.
