# 데이터베이스

## section 1. 데이터베이스의 기본

### 4.1.1 엔터티

엔터티 : 여러 개의 속성을 지닌 명사
A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이면 A는 약한 엔터티, B는 강한 엔터티

### 4.1.2 릴레이션

릴레이션 : 데이터베이스에서 정보를 구분해 저장하는 기본 단위

### 4.1.3 속성

속성 : 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

### 4.1.4 도메인

도메인 : 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

### 4.1.5 필드와 레코드

회원이란 엔터티는 member라는 테이블로 name, id, address 라는 필드를 가진다.
행단위의 데이터를 레코드라하며 튜플이라고도 한다.

### 4.1.6 관계

1:1 관계, 1:N 관계, N:N 관계가 있다.

### 4.1.7 키

테이블 간 관계를 명확히 하고 테이블 자체의 인덱스를 위해 설정된 장치로 기본키, 외래키, 후보키, 슈퍼키, 대체키가 있다.

기본키 : 유일성과 최소성을 만족하는 키
자연키 : 중복된 것들을 제외하다 나오는 키로 언젠가는 변하는 속성을 가진다.
인조키 : 인위적으로 생성한 키, 자연키와는 달리 변하지 않음

외래키 : 다른 테이블의 기본키를 그대로 참조하는 값
후보키 : 기본키가 될 수 있는 후보, 유일성과 최소성 만족
대체키 : 후보키가 두 개 이상을 경우 하나를 기본키로 지정하고 남은 후보키
슈퍼키 : 레코드를 유일하게 식별할 수 있는 유일성 갖춘 키

<br>

## section 2. ERD와 정규화 과정

### 4.2.1 ERD의 중요성

ERD는 시스템의 요구 사항 기반으로 작성되며 이를 기반으로 데이터베이스를 구축한다.

### 4.2.3 정규화 과정

정규화 : 릴레이션 간 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나 이를 해결하고 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정

- 제1정규형 : 릴레이션의 모든 도메인이 원자 값만으로 구성
- 제2정규형 : 제1정규형이며 부분 함수의 종속성을 제거한 형태
- 제3정규형 : 제2정규형이며 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태
- BCNF : 제3정규형이며 릴레이션 함수 종속 관계에서 모든 결정자가 후보키인 상태

<br>

## section 3. 트랜잭션과 무결성

### 4.3.1 트랜잭션

트랜잭션 : 데이터베이스에서 하나의 논리적 기능 수행을 위한 작업의 단위
여러개의 쿼리들을 하나로 묶는 단위

- 원자성 : 트랜잭션 관련 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
- 일관성 : 허용된 방식으로만 데이터를 변경
- 격리성 : 트랜잭션 수행 시 서로 끼어들지 못함
- 지속성 : 성공적으로 수행된 트랜잭션은 영원히 반영

### 4.3.2 무결성

무결성 : 데이터의 정확성, 일관성, 유효성을 유지하는 것

- 개체 무결성 : 기본키로 선택된 필드는 빈 값을 불허
- 참조 무결성 : 서로 참조 관계에 있는 두 테이블 데이터는 항상 일관된 값 유지
- 고유 무결성 : 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유함
- NULL 무결성 : NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없음

<br>

## section 4. 데이터베이스의 종류

### 4.4.1 관계형 데이터베이스

관계형 데이터베이스(RDBMS) : 행과 열을 가지는 표 형식 데이터를 저장하는 데이터베이스
ex) MySQL, PostgreSQL, 오라클, SQL Server, MSSQL

- MySQL : 대부분의 운영체제와 호환되며 가장 많이 쓰이는 데이터베이스
  대용량 데이터베이스를 위해 설계되어 있음
  쿼리 캐시를 지원해 입력된 쿼리 문에 대한 전체 결과 집합을 저장하기에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시

- PostSQL : MySQL 다음으로 개발자들이 선호하는 데이터베이스 기술
  디스크 조각이 차지하는 영역을 회수할 수 있는 VACUUM이 특징

### 4.4.2 NoSQL 데이터베이스

SQL을 사용하지 않는 데이터베이스
ex) MongoDB, redis

- MongoDB : JSON을 통해 데이터에 접근할 수 있고 바이너리 json 형태로 데이터가 저장됨
  확장성이 뛰어나고 빅데이터 저장시 성능이 좋고 스키마를 정해놓지 않고 데이터를 삽입할 수 있어 다양한 도메인의 데이터베이스를 기반으로 분석, 로깅 등을 구현할 때 강점이 있음
  도큐먼트를 생성할 때마다 유니크한 값인 ObjectID가 생성됨

- redis : 인메모리 데이터베이스이자 키-값 데이터 모델 기반 데이터베이스
  채팅 시스템, 실시간 순위표 서비스 등에 사용

<br>

## section 5. 인덱스

### 4.5.1 인덱스의 필요성

인덱스 : 데이터를 빠르게 찾을 수 있는 하나의 장치

### 4.5.2 B-트리

인덱스는 B-트리라는 자료 구조로 이루어진다.
루트노드, 리프노드, 브랜치 노드로 나뉜다.

인덱스가 효율적인 이유는 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문이다.

대수확장성 : 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것

### 4.5.3 인덱스 만드는 방법

- MySQL : 클러스터형 인덱스와 세컨더리 인덱스가 있다.

  - 클러스터형 인덱스 : 테이블 당 하나 설정, ???
  - 세컨더리 인덱스 : 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스

- MongoDB : 도큐먼트를 만들면 자동으로 ObjectID가 형성되며 해당 키가 기본키로 설정

### 4.5.4 인덱스 최적화 기법

1. 인덱스는 비용이다
   인덱스는 두 번 탐색하도록 강요한다. 인덱스 리스트, 컬렉션 순으로 탐색하기 때문이다.
   컬렉션이 수정되면 인덱스도 수정되어야 한다.
   컬렉션에서 가져와야 하는 양이 많을수록 인덱스 사용은 비효율적이다.

2. 항상 테스팅하라
   서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 달라 항상 테스팅하는 것이 중요하다.
   explain()함수를 통해 인덱스를 만들고 쿼리를 보낸 이후 테스팅하며 걸리는 시간을 최소화해야 한다.

3. 복잡 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.
   복합 인덱스는 생성 순서에 따라 인덱스 성능이 달라진다.
   같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 한다.

<br>

## section 6. 조인의 종류

조인(join)이란 두 개 이사의 테이블을 묶어 하나의 결과물을 만드는 것
조인하는 작업이 많을 경우 MongoDB보다는 관계형 데이터베이스를 써야 한다.

### 4.6.1 내부조인

왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
즉, 테이블 간의 교집합

### 4.6.2 왼쪽 조인

왼쪽 테이블의 모든 행이 결과 테이블에 표기
일치하는 항목이 없으면 null

### 4.6.3 오른쪽 조인

오른쪽 테이블의 모든 행이 결과 테이블에 표기
일치하는 항목이 없으면 null

### 4.6.4 합집합 조인

두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기
일치하는 항목이 없으면 누락된 쪽에 null

<br>

## section 7. 조인의 원리

### 4.7.1 중첩 루프 조인

중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법으로 랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서는 사용하지 않는다.

### 4.7.2 정렬 병합 조인

각 테이블을 조인할 필드 기준으로 정렬하고 끝난 이후에 조인 수행
조인할 때 적절한 인덱스가 없고 대용량 테이블을 조인하고 범위 비교 연산자가 있을 때 사용한다.

### 4.7.3 해시 조인

해시 테이블 기반 조인 방법

- 빌드단계 : 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드
- 프로브 단계 : 레코드를 읽기 시작하며 조건에 맞는 레코드 찾아 반환
